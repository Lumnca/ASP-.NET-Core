# :partly_sunny:基本服务配置 #

<p id="t"></p>

:one:[中间件](#a1)



<p id="a1"></p>

### :arrow_forward:中间件 ### 

:arrow_double_up:[返回目录](#t)

**中间件**

`中间件是用于组成应用程序管道来处理请求和响应的组件。管道内的每个组件都可以是否选择将请求交给下一个组件，并在管道中调用组件之前和之后执行某些操作。请求委托被用来建立请求管道，请求委托处理每一个HTTP请求。`

`委托通过使用IApplicationBuilder类型的Run，Map以及Use扩展方法来配置，并在Starup类传给Configure方法。每个单独的请求委托都可以被指定的为一个内嵌匿名方法，或其定义在一个可重用的类中。这些可重用类被称为“中间件”或“中间件组件`

`ASP.NET 请求管道由一系列的请求委托构成它们一个接一个被调用，每个委托在下一个委托之前和之后都有机会执行，任何委托都可以选择停止或传给下一个管道，如果转而自己处理该请求，这就是请求管道的短路`

Vs2017默认站点添加了这些中间组件：

```C#
    public class Startup
    {
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseStaticFiles();
            app.UseCookiePolicy();

            app.UseMvc(routes =>
            {
                routes.MapRoute(
                    name: "default",
                    template: "{controller=Home}/{action=Index}/{id?}");
            });
        }
    }
```

可以看到第一个组件是`app.UseExceptionHandler("/Home/Error");`这是一个捕捉异常的方法，然后传递到/Home/Error所对应的错误响应界面。

以及`UseHttpsRedirection,UseStaticFile，UseCookiePolicy`到最后的路由控制UseMvc。请求在每一步都有可能被阻断，所以我们要以后正确的顺序添加中间组件。如异常处理，我们需要添加在最开始，这样我们第一时间就可以捕捉异常。最简单的ASP .NET 应用程序是使用单个请求委托处理所有请求。这样的话，就不存在管道，调用单个匿名函数以对应每隔HTTP请求：

```C#
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.Run(async context =>
            {
                await context.Response.WriteAsync("Hello World");
            });
        }
```


像这样的话，无论做什么，都只能返回一个hello world。因为第一个app.Run委托中断了管道。所以在该方法下面加上其他中间件都没有用。

**Run,Map,Use方法**

我们可以使用Run，Map，Use方法来配置管道，Run方法会短路管道，强制执行，不会执行next跳到下一个中间组件，因此Run只能在管道最后使用，所以在上面的Run方法后面再加其他方法就不可以再执行其他组件了

```C#
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.Run(async context =>
            {
                await context.Response.WriteAsync("Hello World");
            });
            app.Run(async context =>
            {
                await context.Response.WriteAsync("Hello Lumn");
            });
        }
```

像上面这些的代码只会输出Hello World，不会输出Hello Lumnc.

使用Use方法可以顺序添加组件，如下：

```C#
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                app.UseHsts();
            }
            //-------------添加中间组件-----------
            app.Use(async (context, next) =>
            {
                Console.WriteLine("程序启动");
                await next.Invoke();
                Console.WriteLine("传递给一下中间组件");
            });
            //-------------------------------------
            app.UseHttpsRedirection();
            app.UseStaticFiles();
            app.UseCookiePolicy();

            app.UseMvc(routes =>
            {
                routes.MapRoute(
                    name: "default",
                    template: "{controller=Home}/{action=Index}/{id?}");
            });
            
        }
```

使用Use方法组件的核心是要满足以下格式：

```C#
            app.Use(async (context, next) =>
            {
                ...
                //传递给下一个组件
                await next.Invoke();         
            });
```

其中Use匿名方法参数需要有两个，在方法内部需要传递给下一个组件，否者与Run方法一致。

Map扩展方法只能用于匹配路径请求的请求委托。 Map只接受路径，并配置单独的中间件管道的功能。在下面这个例子中，任何基于路径/hello都会被Hello方法执行：

```C#
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                app.UseHsts();
            }
            app.Use(async (context, next) =>
            {

                Console.WriteLine("程序启动");
                await next.Invoke();
                Console.WriteLine("传递给一下中间组件");
            });
            app.UseHttpsRedirection();
            app.UseStaticFiles();
            app.UseCookiePolicy();

            app.UseMvc(routes =>
            {
                routes.MapRoute(
                    name: "default",
                    template: "{controller=Home}/{action=Index}/{id?}");
            });
            //----map路径映射-------
            app.Map("/hello", Hello); 
        }
        //添加路径/hello执行的方法
        private static void Hello(IApplicationBuilder app)
        {
            app.Run(async context =>
            {
                await context.Response.WriteAsync("Hello Lumnca!");
            });
        }
```

所以使用Map方法需要做两个步骤，第一是配置路径执行方法，第二是配置Map路径映射。执行方法需要在Startup类添加方法。Map路径映射在Configure中添加。

除了基于路径映射之外，MapWhen方法还支持基于谓词的中间件分支，允许以非常灵活的方式构建单独的管道。任何类型Func<HttpContext,bool>类型的谓语都可以被用于将请求映射到新的管道分支。



















